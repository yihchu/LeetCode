<h1>最小高度树</h1>

树是一个无向图，其中任何两个顶点只通过一条路径连接。换句话说，一个任何没有简单环路的连通图都是一棵树。</br>
给你一棵包含n个节点的树，标记为0到n - 1。给定数字n和一个有n - 1条无向边的edges列表（每一个边都是一对标签），其中edges[i] = [a[i], b[i]] 表示树中节点a[i]和b[i]之间存在一条无向边。</br>
可选择树中任何一个节点作为根。当选择节点x作为根节点时，设结果树的高度为h。在所有可能的树中，具有最小高度的树（即，min(h)）被称为最小高度树。</br>
请你找到所有的最小高度树并按任意顺序返回它们的根节点标签列表。</br>
树的高度是指根节点和叶子节点之间最长向下路径上边的数量。</br>

示例1：</br>
</br>![](./image/1.jpeg)</br></br>
输入：n = 4, edges = [[1, 0], [1, 2], [1, 3]]</br>
输出：[1]</br>
解释：如图所示，当根是标签为1的节点时，树的高度是1，这是唯一的最小高度树。</br>

示例2：</br>
</br>![](./image/2.jpeg)</br></br>
输入：n = 6, edges = [[3, 0], [3, 1], [3, 2], [3, 4], [5, 4]]</br>
输出：[3, 4]</br>

提示：</br>
1 <= n <= 2 * 10^4</br>
edges.length == n - 1</br>
0 <= a[i], b[i] < n</br>
a[i] != b[i]</br>
所有(a[i], b[i])互不相同</br>
给定的输入保证是一棵树，并且不会有重复的边</br>

[Link](https://leetcode-cn.com/problems/minimum-height-trees/)