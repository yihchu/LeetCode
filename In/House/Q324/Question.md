<h1>摆动排序II</h1>

给你一个整数数组nums，将它重新排列成nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。</br>
你可以假设所有输入数组都可以得到满足题目要求的结果。</br>

示例1：</br>
输入：nums = [1, 5, 1, 1, 6, 4]</br>
输出：[1, 6, 1, 5, 1, 4]</br>
解释：[1, 4, 1, 5, 1, 6]同样是符合题目要求的结果，可以被判题程序接受。</br>

示例2：</br>
输入：nums = [1, 3, 2, 2, 3, 1]</br>
输出：[2, 3, 1, 3, 1, 2]</br>

提示：</br>
1 <= nums.length <= 5 * 10^4</br>
0 <= nums[i] <= 5000</br>
题目数据保证，对于给定的输入nums，总能产生满足题目要求的结果</br>

进阶：你能用O(n)时间复杂度和/或原地O(1)额外空间来实现吗？</br>

[Link](https://leetcode.cn/problems/wiggle-sort-ii/)